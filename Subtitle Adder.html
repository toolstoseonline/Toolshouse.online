<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Subtitle Adder - separate file inputs</title>
<style>
*{ box-sizing: border-box; }
body{
    margin:0;
    font-family:'Segoe UI',Arial,sans-serif;
    background: linear-gradient(145deg,#1e2b4f,#2d1b3c);
    display:flex;
    justify-content:center;
    align-items:center;
    min-height:100vh;
    padding:15px;
}
.card{
    background:rgba(255,255,255,0.95);
    backdrop-filter:blur(4px);
    width:100%;
    max-width:850px;
    padding:30px 25px;
    border-radius:32px;
    box-shadow:0 30px 50px rgba(0,0,0,0.45);
    border:1px solid rgba(255,255,255,0.3);
}
h2{
    text-align:center;
    margin:0 0 25px 0;
    font-weight:600;
    font-size:2rem;
    color:#1f1a36;
    display:flex;
    align-items:center;
    justify-content:center;
    gap:10px;
}
h2 span{
    background:#fbbf24;
    font-size:1.1rem;
    padding:4px 14px;
    border-radius:60px;
    color:#1e1b4b;
}
.file-grid{
    display:flex;
    flex-wrap:wrap;
    gap:22px;
    margin-bottom:25px;
}
.file-card{
    flex:1 1 250px;
    background:#f8faff;
    border-radius:28px;
    padding:25px 18px 20px;
    box-shadow:inset 0 2px 8px rgba(0,0,0,0.02), 0 8px 18px rgba(99,102,241,0.1);
    border:1px solid #e4e8f5;
    transition:0.25s;
}
.file-card:hover{
    border-color:#818cf8;
    background:#ffffff;
}
.file-header{
    display:flex;
    align-items:center;
    gap:8px;
    font-size:1.4rem;
    font-weight:600;
    margin-bottom:20px;
    color:#312e81;
}
.file-header .badge{
    font-size:0.85rem;
    background:#cbd5e1;
    color:#1e293b;
    padding:2px 12px;
    border-radius:30px;
    margin-left:auto;
}
.upload-btn{
    background:#eef2ff;
    border:2px dashed #a5b4fc;
    border-radius:50px;
    padding:14px 10px;
    text-align:center;
    font-weight:500;
    color:#4338ca;
    cursor:pointer;
    margin:15px 0 12px;
    transition:0.15s;
    display:flex;
    align-items:center;
    justify-content:center;
    gap:8px;
}
.upload-btn:hover{
    background:#dbeafe;
    border-color:#6366f1;
}
.file-name-box{
    background:#ffffff;
    border-radius:40px;
    padding:12px 18px;
    font-size:0.95rem;
    word-break:break-word;
    border:1px solid #cfd9f0;
    color:#1f2937;
    box-shadow:inset 0 1px 3px rgba(0,0,0,0.02);
    max-height:70px;
    overflow-y:auto;
}
.file-name-box i{
    color:#6b7280;
    font-style:normal;
}
.small-hint{
    color:#4b5563;
    font-size:0.8rem;
    margin-top:10px;
    display:flex;
    align-items:center;
    gap:5px;
}
video, canvas{
    width:100%;
    border-radius:28px;
    background:#0f0f1a;
    box-shadow:0 10px 25px rgba(0,0,0,0.3);
    margin-top:5px;
    border:2px solid #b1c3ff;
}
.controls{
    margin-top:28px;
    display:flex;
    flex-wrap:wrap;
    align-items:center;
    justify-content:center;
    gap:15px;
}
button{
    padding:14px 28px;
    border:none;
    border-radius:50px;
    font-weight:600;
    font-size:1rem;
    cursor:pointer;
    transition:0.15s;
    display:inline-flex;
    align-items:center;
    justify-content:center;
    gap:10px;
    box-shadow:0 8px 14px rgba(0,0,0,0.1);
}
.convert-btn{
    background:#4f46e5;
    color:white;
    flex:1 1 auto;
    min-width:180px;
}
.convert-btn:hover{
    background:#4338ca;
    transform:scale(1.02);
    box-shadow:0 12px 18px #4f46e580;
}
.download-btn{
    background:#059669;
    color:white;
    flex:1 1 auto;
    min-width:160px;
}
.download-btn:hover:not(:disabled){
    background:#047857;
    transform:scale(1.02);
}
.download-btn:disabled{
    background:#9ca3af;
    cursor:not-allowed;
    opacity:0.6;
    box-shadow:none;
}
select{
    padding:12px 22px;
    border-radius:60px;
    border:1px solid #b9c4f0;
    background:white;
    font-size:0.95rem;
    font-weight:500;
    color:#1f2937;
    cursor:pointer;
}
.loading{
    display:none;
    text-align:center;
    margin:25px 0 10px;
}
.spinner{
    border:5px solid #e4e8f5;
    border-top:5px solid #4f46e5;
    border-radius:50%;
    width:48px;
    height:48px;
    animation:spin 1s linear infinite;
    margin:0 auto 12px;
}
@keyframes spin{
    0%{transform:rotate(0deg)}
    100%{transform:rotate(360deg)}
}
.error{
    background:#fee2e2;
    color:#b91c1c;
    padding:14px 20px;
    border-radius:50px;
    margin:20px 0 5px;
    font-weight:500;
    border:1px solid #fecaca;
    text-align:center;
}
.reset-btn{
    background:transparent;
    border:1px solid #9aa5b8;
    box-shadow:none;
    padding:8px 20px;
    color:#2d3748;
    font-size:0.9rem;
}
.reset-btn:hover{
    background:#e2e8f0;
    border-color:#64748b;
}
</style>
</head>
<body>
<div class="card">
<h2>üìΩÔ∏è SUBTITLE BURNER <span>separate files</span></h2>

<!-- separate file cards: video (left) and srt (right) -->
<div class="file-grid">
    <!-- VIDEO CARD -->
    <div class="file-card">
        <div class="file-header">
            <span>üé¨</span> Video file
            <span class="badge">MP4, MOV, WebM</span>
        </div>
        <!-- big clickable upload button -->
        <div class="upload-btn" id="videoUploadBtn">
            ‚¨ÜÔ∏è Click or drag to select video
        </div>
        <!-- file name display (live) -->
        <div class="file-name-box" id="videoFileName">
            <i>No video selected</i>
        </div>
        <div class="small-hint">
            <span>üìå</span> max 200MB (no limit, but browser)
        </div>
        <!-- hidden input -->
        <input type="file" id="videoFileInput" accept="video/*" hidden>
    </div>

    <!-- SUBTITLE CARD -->
    <div class="file-card">
        <div class="file-header">
            <span>üìú</span> Subtitle file
            <span class="badge">.srt only</span>
        </div>
        <div class="upload-btn" id="srtUploadBtn">
            ‚¨ÜÔ∏è Click or drag to select SRT
        </div>
        <div class="file-name-box" id="srtFileName">
            <i>No subtitles loaded</i>
        </div>
        <div class="small-hint">
            <span>üî§</span> Text encoding: UTF-8
        </div>
        <input type="file" id="srtFileInput" accept=".srt" hidden>
    </div>
</div>

<!-- separate reset buttons -->
<div style="display:flex; gap:10px; justify-content:flex-end; margin-bottom:15px;">
    <button class="reset-btn" id="clearVideoBtn">üóëÔ∏è Clear video</button>
    <button class="reset-btn" id="clearSrtBtn">üóëÔ∏è Clear subtitles</button>
</div>

<!-- video preview element -->
<video id="videoPreview" controls></video>
<canvas id="canvas" style="display:none;"></canvas>

<!-- format and action buttons -->
<div class="controls">
    <select id="formatSelector">
        <option value="video/webm">WebM (VP8) - high compatibility</option>
        <option value="video/webm;codecs=vp9">WebM (VP9) - better compression</option>
    </select>
    <button class="convert-btn" id="convertBtn">‚ú® BURN SUBTITLES</button>
    <button class="download-btn" id="downloadBtn" disabled>üíæ Download video</button>
</div>

<!-- loading indicator & error -->
<div class="loading" id="loadingIndicator">
    <div class="spinner"></div>
    <strong>Encoding subtitles‚Ä¶</strong> (wait until video ends)
</div>
<div class="error" id="errorMsg"></div>

<script>
(function() {
    // ----- DOM elements -----
    const videoPreview = document.getElementById('videoPreview');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const convertBtn = document.getElementById('convertBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const formatSelector = document.getElementById('formatSelector');
    const loading = document.getElementById('loadingIndicator');
    const errorMsgDiv = document.getElementById('errorMsg');

    // video elements
    const videoFileInput = document.getElementById('videoFileInput');
    const videoUploadBtn = document.getElementById('videoUploadBtn');
    const videoFileNameDiv = document.getElementById('videoFileName');
    const clearVideoBtn = document.getElementById('clearVideoBtn');

    // srt elements
    const srtFileInput = document.getElementById('srtFileInput');
    const srtUploadBtn = document.getElementById('srtUploadBtn');
    const srtFileNameDiv = document.getElementById('srtFileName');
    const clearSrtBtn = document.getElementById('clearSrtBtn');

    // state
    let subtitles = [];               // parsed subtitles
    let recordedBlob = null;
    let currentVideoBlobUrl = null;

    // ----- helper: clear error -----
    function setError(text) {
        errorMsgDiv.textContent = text;
    }

    // ----- video file handling (click & drag) -----
    function handleVideoFile(file) {
        if (!file || !file.type.startsWith('video/')) {
            setError('Please select a valid video file (MP4, WebM, MOV).');
            return;
        }
        // revoke previous url
        if (currentVideoBlobUrl) {
            URL.revokeObjectURL(currentVideoBlobUrl);
        }
        currentVideoBlobUrl = URL.createObjectURL(file);
        videoPreview.src = currentVideoBlobUrl;
        videoPreview.load(); // ensure it loads
        videoFileNameDiv.innerHTML = `<span style="color:#1e40af;">‚úÖ</span> ${file.name}`;
        setError(''); // clear any previous error
        recordedBlob = null;
        downloadBtn.disabled = true;
    }

    videoUploadBtn.addEventListener('click', () => videoFileInput.click());
    videoFileInput.addEventListener('change', (e) => {
        if (e.target.files.length) handleVideoFile(e.target.files[0]);
    });

    // drag & drop for video card
    videoUploadBtn.addEventListener('dragover', (e) => e.preventDefault());
    videoUploadBtn.addEventListener('drop', (e) => {
        e.preventDefault();
        const files = e.dataTransfer.files;
        if (files.length) {
            const videoFile = Array.from(files).find(f => f.type.startsWith('video/'));
            if (videoFile) {
                handleVideoFile(videoFile);
                // sync input (optional, can't set .files directly)
            } else {
                setError('No video file in dropped items.');
            }
        }
    });

    // ----- srt file handling -----
    function handleSrtFile(file) {
        if (!file || !file.name.toLowerCase().endsWith('.srt')) {
            setError('Please select a valid .srt subtitle file.');
            return;
        }
        const reader = new FileReader();
        reader.onload = (ev) => {
            parseSRT(ev.target.result);
            if (subtitles.length) {
                srtFileNameDiv.innerHTML = `<span style="color:#1e40af;">‚úÖ</span> ${file.name} (${subtitles.length} subs)`;
                setError('');
            } else {
                srtFileNameDiv.innerHTML = `<span style="color:#b91c1c;">‚ö†Ô∏è</span> ${file.name} (no valid cues)`;
                setError('SRT parsed but no valid subtitle blocks found.');
            }
            recordedBlob = null;
            downloadBtn.disabled = true;
        };
        reader.readAsText(file, 'UTF-8');
    }

    srtUploadBtn.addEventListener('click', () => srtFileInput.click());
    srtFileInput.addEventListener('change', (e) => {
        if (e.target.files.length) handleSrtFile(e.target.files[0]);
    });

    // drag & drop for srt card
    srtUploadBtn.addEventListener('dragover', (e) => e.preventDefault());
    srtUploadBtn.addEventListener('drop', (e) => {
        e.preventDefault();
        const files = e.dataTransfer.files;
        if (files.length) {
            const srtFile = Array.from(files).find(f => f.name.endsWith('.srt'));
            if (srtFile) handleSrtFile(srtFile);
            else setError('Dropped item is not an .srt file.');
        }
    });

    // ----- clear buttons -----
    clearVideoBtn.addEventListener('click', () => {
        if (currentVideoBlobUrl) {
            URL.revokeObjectURL(currentVideoBlobUrl);
            currentVideoBlobUrl = null;
        }
        videoPreview.src = '';
        videoFileInput.value = '';
        videoFileNameDiv.innerHTML = '<i>No video selected</i>';
        recordedBlob = null;
        downloadBtn.disabled = true;
        setError('');
    });

    clearSrtBtn.addEventListener('click', () => {
        srtFileInput.value = '';
        srtFileNameDiv.innerHTML = '<i>No subtitles loaded</i>';
        subtitles = [];
        recordedBlob = null;
        downloadBtn.disabled = true;
        setError('');
    });

    // ----- SRT parser (robust) -----
    function parseSRT(data) {
        subtitles = [];
        const blocks = data.split(/\r?\n\r?\n/);
        for (let block of blocks) {
            const lines = block.split(/\r?\n/).filter(l => l.trim() !== '');
            if (lines.length < 2) continue;
            // identify timecode line (contains -->)
            let timeIdx = -1;
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].includes('-->')) {
                    timeIdx = i;
                    break;
                }
            }
            if (timeIdx === -1) continue;
            const timeLine = lines[timeIdx];
            const textLines = lines.slice(timeIdx + 1).join(' ').trim();
            if (!textLines) continue;

            const parts = timeLine.split('-->');
            if (parts.length < 2) continue;
            const startStr = parts[0].trim().replace(/,/g, '.');
            const endStr = parts[1].trim().replace(/,/g, '.');
            const start = convertTime(startStr);
            const end = convertTime(endStr);
            if (isNaN(start) || isNaN(end)) continue;

            subtitles.push({ start, end, text: textLines });
        }
    }

    function convertTime(t) {
        const parts = t.split(':');
        if (parts.length === 3) {
            const secParts = parts[2].split('.');
            const sec = parseInt(secParts[0], 10);
            const ms = secParts[1] ? parseInt(secParts[1].padEnd(3, '0').slice(0,3), 10) : 0;
            return parseInt(parts[0],10)*3600 + parseInt(parts[1],10)*60 + sec + ms/1000;
        }
        return NaN;
    }

    // ----- convert (burn subtitles) -----
    convertBtn.addEventListener('click', async () => {
        // validations
        if (!videoPreview.src || videoPreview.readyState < 2) {
            setError('Video not loaded or metadata missing. Please load a video and wait.');
            return;
        }
        if (subtitles.length === 0) {
            setError('No subtitles loaded. Upload a valid .srt file.');
            return;
        }

        // canvas size from video
        canvas.width = videoPreview.videoWidth;
        canvas.height = videoPreview.videoHeight;
        if (canvas.width === 0 || canvas.height === 0) {
            setError('Video resolution not available (try playing video once).');
            return;
        }

        loading.style.display = 'block';
        downloadBtn.disabled = true;
        setError('');

        // select mime
        let mime = formatSelector.value;
        if (!MediaRecorder.isTypeSupported(mime)) {
            if (MediaRecorder.isTypeSupported('video/webm')) {
                mime = 'video/webm';
            } else {
                setError('WebM recording not supported in this browser.');
                loading.style.display = 'none';
                return;
            }
        }

        const stream = canvas.captureStream(30); // 30 fps
        let recorder;
        try {
            recorder = new MediaRecorder(stream, { mimeType: mime });
        } catch (err) {
            setError('MediaRecorder error: ' + err.message);
            loading.style.display = 'none';
            return;
        }

        const chunks = [];
        recorder.ondataavailable = (e) => chunks.push(e.data);
        recorder.onstop = () => {
            recordedBlob = new Blob(chunks, { type: mime });
            downloadBtn.disabled = false;
            loading.style.display = 'none';
        };

        recorder.start();
        videoPreview.play();

        function drawFrame() {
            if (videoPreview.paused || videoPreview.ended) {
                if (recorder.state !== 'inactive') recorder.stop();
                return;
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(videoPreview, 0, 0, canvas.width, canvas.height);
            const current = videoPreview.currentTime;

            ctx.font = 'bold 36px "Segoe UI", Arial, sans-serif';
            ctx.fillStyle = 'white';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 4;
            ctx.textAlign = 'center';
            ctx.shadowColor = 'black';
            ctx.shadowBlur = 8;

            subtitles.forEach(sub => {
                if (current >= sub.start && current <= sub.end) {
                    ctx.strokeText(sub.text, canvas.width/2, canvas.height - 50);
                    ctx.fillText(sub.text, canvas.width/2, canvas.height - 50);
                }
            });
            ctx.shadowBlur = 0; // reset
            requestAnimationFrame(drawFrame);
        }
        drawFrame();
    });

    // download
    downloadBtn.addEventListener('click', () => {
        if (recordedBlob) {
            const url = URL.createObjectURL(recordedBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'subtitled_video.webm';
            a.click();
            URL.revokeObjectURL(url);
        }
    });

    // small adjustment: if video ends before recorder, stop properly
    videoPreview.addEventListener('ended', () => {
        // if recording, stop (though draw loop also stops)
    });

    // initially no file
})();
</script>
</body>
</html>
