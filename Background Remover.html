<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BG.ERASER â€” Background Remover</title>
<link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Bebas+Neue&family=DM+Sans:wght@300;400;500&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #0a0a0f;
    --surface: #12121a;
    --border: #1e1e2e;
    --accent: #00ff88;
    --accent2: #ff3366;
    --text: #e8e8f0;
    --muted: #555570;
    --card: #16161f;
  }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'DM Sans', sans-serif;
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* Animated grid background */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background-image: 
      linear-gradient(rgba(0,255,136,0.03) 1px, transparent 1px),
      linear-gradient(90deg, rgba(0,255,136,0.03) 1px, transparent 1px);
    background-size: 40px 40px;
    pointer-events: none;
    z-index: 0;
  }

  /* Glow blob */
  body::after {
    content: '';
    position: fixed;
    width: 600px;
    height: 600px;
    background: radial-gradient(circle, rgba(0,255,136,0.06) 0%, transparent 70%);
    top: -200px;
    right: -200px;
    pointer-events: none;
    z-index: 0;
  }

  .container {
    position: relative;
    z-index: 1;
    max-width: 1100px;
    margin: 0 auto;
    padding: 0 24px;
  }

  /* HEADER */
  header {
    padding: 32px 0 24px;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .logo {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 2rem;
    letter-spacing: 4px;
    color: var(--accent);
    text-shadow: 0 0 30px rgba(0,255,136,0.4);
  }

  .logo span { color: var(--text); }

  .badge {
    font-family: 'Space Mono', monospace;
    font-size: 0.65rem;
    padding: 4px 10px;
    border: 1px solid var(--accent);
    color: var(--accent);
    letter-spacing: 2px;
    border-radius: 2px;
  }

  /* HERO */
  .hero {
    text-align: center;
    padding: 48px 0 40px;
  }

  .hero h1 {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(3rem, 8vw, 6rem);
    letter-spacing: 6px;
    line-height: 1;
    background: linear-gradient(135deg, #fff 30%, var(--accent) 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 16px;
  }

  .hero p {
    color: var(--muted);
    font-size: 1rem;
    font-weight: 300;
    letter-spacing: 1px;
    font-family: 'Space Mono', monospace;
  }

  /* MAIN TOOL AREA */
  .tool-wrapper {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 24px;
    margin-bottom: 32px;
  }

  @media (max-width: 700px) {
    .tool-wrapper { grid-template-columns: 1fr; }
  }

  .panel {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 12px;
    overflow: hidden;
    position: relative;
  }

  .panel-header {
    padding: 14px 20px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    gap: 10px;
    font-family: 'Space Mono', monospace;
    font-size: 0.7rem;
    letter-spacing: 2px;
    color: var(--muted);
    text-transform: uppercase;
  }

  .dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--accent);
    box-shadow: 0 0 8px var(--accent);
  }

  .dot.red { background: var(--accent2); box-shadow: 0 0 8px var(--accent2); }

  /* UPLOAD ZONE */
  .upload-zone {
    aspect-ratio: 4/3;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    background: repeating-linear-gradient(
      45deg,
      transparent,
      transparent 10px,
      rgba(255,255,255,0.01) 10px,
      rgba(255,255,255,0.01) 20px
    );
  }

  .upload-zone:hover, .upload-zone.dragover {
    background: rgba(0,255,136,0.04);
    border-color: var(--accent);
  }

  .upload-zone.has-image {
    padding: 0;
    background: none;
  }

  .upload-icon {
    font-size: 3rem;
    margin-bottom: 16px;
    opacity: 0.3;
    transition: all 0.3s;
  }

  .upload-zone:hover .upload-icon {
    opacity: 0.6;
    transform: scale(1.1);
  }

  .upload-text {
    font-family: 'Space Mono', monospace;
    font-size: 0.75rem;
    color: var(--muted);
    letter-spacing: 1px;
    text-align: center;
    line-height: 1.8;
  }

  .upload-text strong {
    display: block;
    color: var(--text);
    font-size: 0.9rem;
    margin-bottom: 6px;
  }

  #fileInput { display: none; }

  #sourcePreview {
    width: 100%;
    height: 100%;
    object-fit: contain;
    display: none;
  }

  /* OUTPUT PANEL */
  .output-zone {
    aspect-ratio: 4/3;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
  }

  /* Checkerboard for transparent bg */
  .checkerboard {
    position: absolute;
    inset: 0;
    background-image: 
      linear-gradient(45deg, #1a1a24 25%, transparent 25%),
      linear-gradient(-45deg, #1a1a24 25%, transparent 25%),
      linear-gradient(45deg, transparent 75%, #1a1a24 75%),
      linear-gradient(-45deg, transparent 75%, #1a1a24 75%);
    background-size: 20px 20px;
    background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
    display: none;
  }

  .output-placeholder {
    font-family: 'Space Mono', monospace;
    font-size: 0.7rem;
    color: var(--muted);
    text-align: center;
    letter-spacing: 1px;
  }

  #outputCanvas {
    position: relative;
    z-index: 1;
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    display: none;
  }

  /* CONTROLS */
  .controls {
    padding: 24px;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 12px;
    margin-bottom: 24px;
    display: grid;
    grid-template-columns: 1fr auto;
    align-items: center;
    gap: 24px;
  }

  .settings-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    gap: 20px;
  }

  .setting-item label {
    display: block;
    font-family: 'Space Mono', monospace;
    font-size: 0.65rem;
    letter-spacing: 2px;
    color: var(--muted);
    text-transform: uppercase;
    margin-bottom: 8px;
  }

  .slider-wrapper {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  input[type="range"] {
    flex: 1;
    -webkit-appearance: none;
    height: 3px;
    background: var(--border);
    border-radius: 2px;
    outline: none;
    cursor: pointer;
  }

  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: var(--accent);
    box-shadow: 0 0 10px rgba(0,255,136,0.5);
    cursor: pointer;
    transition: transform 0.2s;
  }

  input[type="range"]::-webkit-slider-thumb:hover {
    transform: scale(1.3);
  }

  .val-display {
    font-family: 'Space Mono', monospace;
    font-size: 0.75rem;
    color: var(--accent);
    min-width: 28px;
    text-align: right;
  }

  /* SELECT */
  select {
    width: 100%;
    padding: 8px 12px;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text);
    font-family: 'Space Mono', monospace;
    font-size: 0.75rem;
    cursor: pointer;
    outline: none;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23555570' viewBox='0 0 16 16'%3E%3Cpath d='M7.247 11.14L2.451 5.658C1.885 5.013 2.345 4 3.204 4h9.592a1 1 0 0 1 .753 1.659l-4.796 5.48a1 1 0 0 1-1.506 0z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 10px center;
    background-size: 12px;
  }

  select:focus { border-color: var(--accent); }

  /* BUTTONS */
  .btn-group {
    display: flex;
    flex-direction: column;
    gap: 10px;
    min-width: 160px;
  }

  .btn {
    padding: 14px 24px;
    border: none;
    border-radius: 8px;
    font-family: 'Space Mono', monospace;
    font-size: 0.75rem;
    letter-spacing: 2px;
    text-transform: uppercase;
    cursor: pointer;
    transition: all 0.2s ease;
    position: relative;
    overflow: hidden;
  }

  .btn-primary {
    background: var(--accent);
    color: #000;
    font-weight: 700;
  }

  .btn-primary::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, rgba(255,255,255,0.2) 0%, transparent 100%);
    opacity: 0;
    transition: opacity 0.2s;
  }

  .btn-primary:hover::before { opacity: 1; }
  .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 8px 24px rgba(0,255,136,0.3); }
  .btn-primary:active { transform: translateY(0); }
  .btn-primary:disabled { opacity: 0.4; cursor: not-allowed; transform: none; box-shadow: none; }

  .btn-secondary {
    background: transparent;
    color: var(--text);
    border: 1px solid var(--border);
  }

  .btn-secondary:hover:not(:disabled) { 
    border-color: var(--accent); 
    color: var(--accent); 
    transform: translateY(-2px); 
  }

  .btn-secondary:disabled { opacity: 0.3; cursor: not-allowed; }

  /* PROGRESS */
  .progress-bar {
    width: 100%;
    height: 3px;
    background: var(--border);
    border-radius: 2px;
    overflow: hidden;
    display: none;
    margin-top: 12px;
  }

  .progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--accent), #00ccff);
    width: 0%;
    transition: width 0.3s ease;
    box-shadow: 0 0 10px rgba(0,255,136,0.5);
  }

  /* STATUS */
  .status {
    font-family: 'Space Mono', monospace;
    font-size: 0.7rem;
    color: var(--muted);
    letter-spacing: 1px;
    margin-top: 8px;
    min-height: 16px;
    transition: color 0.3s;
  }

  .status.success { color: var(--accent); }
  .status.error { color: var(--accent2); }
  .status.processing { color: #00ccff; }

  /* PROCESSING ANIMATION */
  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  .spinner {
    display: inline-block;
    width: 10px;
    height: 10px;
    border: 2px solid var(--border);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
    margin-right: 8px;
    vertical-align: middle;
  }

  /* COLOR PICKER */
  input[type="color"] {
    width: 100%;
    height: 36px;
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 2px;
    background: var(--bg);
    cursor: pointer;
  }

  /* TIPS */
  .tips {
    display: flex;
    gap: 16px;
    margin-bottom: 32px;
    flex-wrap: wrap;
  }

  .tip {
    flex: 1;
    min-width: 200px;
    padding: 16px 20px;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 10px;
    font-size: 0.8rem;
    color: var(--muted);
    line-height: 1.6;
  }

  .tip-icon { font-size: 1.2rem; margin-bottom: 6px; display: block; }
  .tip strong { display: block; color: var(--text); margin-bottom: 4px; font-size: 0.8rem; }

  /* FOOTER */
  footer {
    text-align: center;
    padding: 32px 0;
    border-top: 1px solid var(--border);
    font-family: 'Space Mono', monospace;
    font-size: 0.65rem;
    color: var(--muted);
    letter-spacing: 2px;
  }

  /* LOADING OVERLAY */
  .loading-overlay {
    position: absolute;
    inset: 0;
    background: rgba(10,10,15,0.85);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 10;
    flex-direction: column;
    gap: 16px;
    backdrop-filter: blur(4px);
  }

  .loading-overlay.active { display: flex; }

  .loader-ring {
    width: 60px;
    height: 60px;
    border: 3px solid var(--border);
    border-top: 3px solid var(--accent);
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  .loader-text {
    font-family: 'Space Mono', monospace;
    font-size: 0.7rem;
    color: var(--accent);
    letter-spacing: 3px;
    animation: pulse 1.5s ease-in-out infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 0.4; }
    50% { opacity: 1; }
  }

  /* FADE IN */
  @keyframes fadeUp {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .container > * {
    animation: fadeUp 0.6s ease both;
  }
  header { animation-delay: 0s; }
  .hero { animation-delay: 0.1s; }
  .tool-wrapper { animation-delay: 0.2s; }
  .controls { animation-delay: 0.3s; }
  .tips { animation-delay: 0.4s; }
</style>
</head>
<body>
<div class="container">
  <header>
    <div class="logo">BG<span>.</span>ERASER</div>
    <div class="badge">100% LOCAL Â· NO UPLOAD</div>
  </header>

  <div class="hero">
    <h1>REMOVE BACKGROUNDS</h1>
    <p>// CLIENT-SIDE PROCESSING Â· INSTANT Â· PRIVATE</p>
  </div>

  <div class="tool-wrapper">
    <!-- INPUT PANEL -->
    <div class="panel">
      <div class="panel-header">
        <div class="dot"></div>
        INPUT IMAGE
      </div>
      <div class="upload-zone" id="uploadZone" onclick="document.getElementById('fileInput').click()">
        <div class="upload-icon">â¬†</div>
        <div class="upload-text">
          <strong>Drop image here</strong>
          Click to browse or drag & drop<br>
          PNG Â· JPG Â· WEBP supported
        </div>
        <img id="sourcePreview" alt="Source">
      </div>
      <div class="loading-overlay" id="loadingOverlay">
        <div class="loader-ring"></div>
        <div class="loader-text">PROCESSING...</div>
      </div>
      <input type="file" id="fileInput" accept="image/*">
    </div>

    <!-- OUTPUT PANEL -->
    <div class="panel">
      <div class="panel-header">
        <div class="dot red"></div>
        OUTPUT (BACKGROUND REMOVED)
      </div>
      <div class="output-zone" id="outputZone">
        <div class="checkerboard" id="checkerboard"></div>
        <div class="output-placeholder" id="outputPlaceholder">
          â¬›<br><br>
          Result will appear here
        </div>
        <canvas id="outputCanvas"></canvas>
      </div>
    </div>
  </div>

  <!-- CONTROLS -->
  <div class="controls">
    <div class="settings-grid">
      <div class="setting-item">
        <label>Tolerance</label>
        <div class="slider-wrapper">
          <input type="range" id="tolerance" min="1" max="120" value="30">
          <span class="val-display" id="toleranceVal">30</span>
        </div>
      </div>
      <div class="setting-item">
        <label>Edge Smooth</label>
        <div class="slider-wrapper">
          <input type="range" id="smoothing" min="0" max="10" value="2">
          <span class="val-display" id="smoothingVal">2</span>
        </div>
      </div>
      <div class="setting-item">
        <label>Mode</label>
        <select id="modeSelect">
          <option value="corner">Corner-based (Auto)</option>
          <option value="flood">Flood Fill</option>
          <option value="color">Color Range</option>
        </select>
      </div>
      <div class="setting-item" id="bgColorGroup">
        <label>Replace With</label>
        <select id="bgFill">
          <option value="transparent">Transparent</option>
          <option value="white">White</option>
          <option value="black">Black</option>
          <option value="custom">Custom Color</option>
        </select>
      </div>
      <div class="setting-item" id="customColorGroup" style="display:none;">
        <label>Custom Color</label>
        <input type="color" id="customColor" value="#ffffff">
      </div>
    </div>

    <div class="btn-group">
      <button class="btn btn-primary" id="removeBtn" disabled onclick="removeBackground()">
        REMOVE BG
      </button>
      <button class="btn btn-secondary" id="downloadBtn" disabled onclick="downloadResult()">
        DOWNLOAD
      </button>
      <button class="btn btn-secondary" onclick="resetTool()">
        RESET
      </button>
      <div class="progress-bar" id="progressBar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      <div class="status" id="status"></div>
    </div>
  </div>

  <!-- TIPS -->
  <div class="tips">
    <div class="tip">
      <span class="tip-icon">ðŸŽ¯</span>
      <strong>Best Results</strong>
      Works best on images with clear, distinct backgrounds. High contrast between subject and background gives cleaner results.
    </div>
    <div class="tip">
      <span class="tip-icon">ðŸ”§</span>
      <strong>Tune Tolerance</strong>
      Lower tolerance = more precise but may miss areas. Higher tolerance = broader removal. Adjust per image.
    </div>
    <div class="tip">
      <span class="tip-icon">ðŸ”’</span>
      <strong>100% Private</strong>
      All processing happens in your browser. No images are ever uploaded to any server.
    </div>
  </div>

  <footer>Â© 2025 BG.ERASER â€” ALL RIGHTS RESERVED Â· BUILT WITH CANVAS API</footer>
</div>

<script>
const fileInput = document.getElementById('fileInput');
const uploadZone = document.getElementById('uploadZone');
const sourcePreview = document.getElementById('sourcePreview');
const outputCanvas = document.getElementById('outputCanvas');
const outputPlaceholder = document.getElementById('outputPlaceholder');
const checkerboard = document.getElementById('checkerboard');
const removeBtn = document.getElementById('removeBtn');
const downloadBtn = document.getElementById('downloadBtn');
const status = document.getElementById('status');
const progressBar = document.getElementById('progressBar');
const progressFill = document.getElementById('progressFill');

let originalImage = null;
let ctx = null;

// Range sliders
document.getElementById('tolerance').addEventListener('input', e => {
  document.getElementById('toleranceVal').textContent = e.target.value;
});
document.getElementById('smoothing').addEventListener('input', e => {
  document.getElementById('smoothingVal').textContent = e.target.value;
});

// BG fill toggle
document.getElementById('bgFill').addEventListener('change', e => {
  document.getElementById('customColorGroup').style.display = 
    e.target.value === 'custom' ? 'block' : 'none';
});

// Drag & Drop
uploadZone.addEventListener('dragover', e => {
  e.preventDefault();
  uploadZone.classList.add('dragover');
});

uploadZone.addEventListener('dragleave', () => {
  uploadZone.classList.remove('dragover');
});

uploadZone.addEventListener('drop', e => {
  e.preventDefault();
  uploadZone.classList.remove('dragover');
  const file = e.dataTransfer.files[0];
  if (file && file.type.startsWith('image/')) loadFile(file);
});

fileInput.addEventListener('change', e => {
  if (e.target.files[0]) loadFile(e.target.files[0]);
});

function loadFile(file) {
  const reader = new FileReader();
  reader.onload = ev => {
    const img = new Image();
    img.onload = () => {
      originalImage = img;
      sourcePreview.src = ev.target.result;
      sourcePreview.style.display = 'block';
      uploadZone.classList.add('has-image');
      uploadZone.querySelector('.upload-icon').style.display = 'none';
      uploadZone.querySelector('.upload-text').style.display = 'none';
      removeBtn.disabled = false;
      downloadBtn.disabled = true;
      outputCanvas.style.display = 'none';
      outputPlaceholder.style.display = 'block';
      checkerboard.style.display = 'none';
      setStatus('Image loaded â€” ready to process', '');
    };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(file);
}

function setStatus(msg, type) {
  status.textContent = msg;
  status.className = 'status ' + (type || '');
}

function setProgress(pct) {
  progressBar.style.display = 'block';
  progressFill.style.width = pct + '%';
  if (pct >= 100) {
    setTimeout(() => { progressBar.style.display = 'none'; progressFill.style.width = '0%'; }, 600);
  }
}

async function removeBackground() {
  if (!originalImage) return;

  removeBtn.disabled = true;
  setStatus('', 'processing');

  // Draw original to offscreen canvas
  const offCanvas = document.createElement('canvas');
  offCanvas.width = originalImage.width;
  offCanvas.height = originalImage.height;
  const offCtx = offCanvas.getContext('2d');
  offCtx.drawImage(originalImage, 0, 0);

  const imageData = offCtx.getImageData(0, 0, offCanvas.width, offCanvas.height);
  const data = imageData.data;
  const W = offCanvas.width;
  const H = offCanvas.height;
  const tolerance = parseInt(document.getElementById('tolerance').value);
  const smoothing = parseInt(document.getElementById('smoothing').value);
  const mode = document.getElementById('modeSelect').value;

  setStatus('<span class="spinner"></span>Processing pixels...', 'processing');
  status.innerHTML = '<span class="spinner"></span>Processing pixels...';
  setProgress(10);

  await sleep(30);

  let mask = new Uint8Array(W * H); // 1 = keep, 0 = remove

  if (mode === 'corner' || mode === 'flood') {
    // Sample background color from corners
    const bgColors = [];
    const cornerOffsets = [
      [0, 0], [W-1, 0], [0, H-1], [W-1, H-1],
      [Math.floor(W/2), 0], [0, Math.floor(H/2)],
      [W-1, Math.floor(H/2)], [Math.floor(W/2), H-1]
    ];
    for (const [cx, cy] of cornerOffsets) {
      const idx = (cy * W + cx) * 4;
      bgColors.push([data[idx], data[idx+1], data[idx+2]]);
    }

    // Flood fill from corners
    const visited = new Uint8Array(W * H);
    const queue = [];

    for (const [cx, cy] of cornerOffsets) {
      const idx = cy * W + cx;
      if (!visited[idx]) {
        visited[idx] = 1;
        queue.push([cx, cy]);
      }
    }

    setProgress(30);
    await sleep(10);

    const neighbors = [[-1,0],[1,0],[0,-1],[0,1]];

    let qi = 0;
    while (qi < queue.length) {
      const [x, y] = queue[qi++];
      const pixIdx = (y * W + x) * 4;
      const r = data[pixIdx], g = data[pixIdx+1], b = data[pixIdx+2];

      // Check if close enough to any bg color
      let isBg = false;
      for (const [br, bg, bb] of bgColors) {
        const dist = Math.sqrt((r-br)**2 + (g-bg)**2 + (b-bb)**2);
        if (dist <= tolerance) { isBg = true; break; }
      }

      if (isBg) {
        mask[y * W + x] = 0; // remove
        for (const [dx, dy] of neighbors) {
          const nx = x + dx, ny = y + dy;
          if (nx >= 0 && nx < W && ny >= 0 && ny < H) {
            const ni = ny * W + nx;
            if (!visited[ni]) {
              visited[ni] = 1;
              queue.push([nx, ny]);
            }
          }
        }
      } else {
        mask[y * W + x] = 1; // keep
      }

      if (qi % 50000 === 0) {
        setProgress(30 + Math.min(40, (qi / (W*H)) * 40));
        await sleep(0);
      }
    }

    // Fill unvisited pixels as keep
    for (let i = 0; i < W * H; i++) {
      if (!visited[i]) mask[i] = 1;
    }

  } else if (mode === 'color') {
    // Color range â€” sample center 4 corners and remove matching
    const midX = Math.floor(W/2), midY = Math.floor(H/2);
    const sampleIdx = (0 * W + 0) * 4;
    const bgR = data[sampleIdx], bgG = data[sampleIdx+1], bgB = data[sampleIdx+2];

    for (let i = 0; i < W * H; i++) {
      const idx = i * 4;
      const dist = Math.sqrt(
        (data[idx]-bgR)**2 + (data[idx+1]-bgG)**2 + (data[idx+2]-bgB)**2
      );
      mask[i] = dist > tolerance ? 1 : 0;
    }
  }

  setProgress(75);
  await sleep(10);

  // Apply smoothing (simple box blur on mask edges)
  if (smoothing > 0) {
    const smoothedMask = new Float32Array(W * H);
    for (let i = 0; i < W * H; i++) smoothedMask[i] = mask[i];

    for (let pass = 0; pass < smoothing; pass++) {
      for (let y = 1; y < H-1; y++) {
        for (let x = 1; x < W-1; x++) {
          const i = y * W + x;
          smoothedMask[i] = (
            mask[(y-1)*W+x] + mask[(y+1)*W+x] +
            mask[y*W+(x-1)] + mask[y*W+(x+1)] +
            mask[i] * 2
          ) / 6;
        }
      }
    }

    for (let i = 0; i < W * H; i++) {
      mask[i] = smoothedMask[i] > 0.5 ? 1 : 0;
    }
  }

  setProgress(90);
  await sleep(10);

  // Get fill color
  const bgFill = document.getElementById('bgFill').value;
  let fillR = 0, fillG = 0, fillB = 0, fillA = 0;
  if (bgFill === 'white') { fillR = fillG = fillB = 255; fillA = 255; }
  else if (bgFill === 'black') { fillR = fillG = fillB = 0; fillA = 255; }
  else if (bgFill === 'custom') {
    const hex = document.getElementById('customColor').value;
    fillR = parseInt(hex.slice(1,3),16);
    fillG = parseInt(hex.slice(3,5),16);
    fillB = parseInt(hex.slice(5,7),16);
    fillA = 255;
  }

  // Apply mask to pixel data
  for (let i = 0; i < W * H; i++) {
    const idx = i * 4;
    if (mask[i] === 0) {
      data[idx] = fillR;
      data[idx+1] = fillG;
      data[idx+2] = fillB;
      data[idx+3] = fillA;
    }
  }

  // Render output
  outputCanvas.width = W;
  outputCanvas.height = H;
  ctx = outputCanvas.getContext('2d');
  ctx.putImageData(imageData, 0, 0);

  outputCanvas.style.display = 'block';
  outputPlaceholder.style.display = 'none';
  if (bgFill === 'transparent') {
    checkerboard.style.display = 'block';
  }

  setProgress(100);
  setStatus('âœ“ Background removed successfully!', 'success');
  removeBtn.disabled = false;
  downloadBtn.disabled = false;
}

function downloadResult() {
  if (!outputCanvas.width) return;
  const link = document.createElement('a');
  link.download = 'bg-removed.png';
  link.href = outputCanvas.toDataURL('image/png');
  link.click();
  setStatus('âœ“ Downloaded!', 'success');
}

function resetTool() {
  originalImage = null;
  fileInput.value = '';
  sourcePreview.style.display = 'none';
  sourcePreview.src = '';
  uploadZone.classList.remove('has-image');
  uploadZone.querySelector('.upload-icon').style.display = '';
  uploadZone.querySelector('.upload-text').style.display = '';
  outputCanvas.style.display = 'none';
  outputCanvas.width = 0;
  checkerboard.style.display = 'none';
  outputPlaceholder.style.display = 'block';
  removeBtn.disabled = true;
  downloadBtn.disabled = true;
  progressBar.style.display = 'none';
  setStatus('Reset complete', '');
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
</script>
</body>
</html>
